{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Busy Beaver Turing Machine Simulator","text":"<p>Welcome to the Busy Beaver Turing Machine Simulator! \ud83e\uddab</p>"},{"location":"#what-is-a-busy-beaver","title":"\ud83e\udde0 What is a Busy Beaver?","text":"<p>The Busy Beaver problem explores the limits of computation by seeking the Turing machine with the maximum number of <code>1</code>s printed on the tape before halting, given a fixed number of states and symbols. It's a fascinating journey into the boundaries of what machines can compute.</p>"},{"location":"#features","title":"\ud83d\ude80 Features","text":"<ul> <li>Modular Design: Clean separation of concerns for scalability and maintainability.</li> <li>Multiprocessing: Efficiently simulates multiple Turing machines in parallel, speeding up the exploration process.</li> <li>Comprehensive Reporting: Identifies and reports the most productive and longest-running halting machines.</li> <li>Extensible: Easily modify the number of states, symbols, and other configurations to explore various scenarios.</li> <li>User-Friendly Interface: Simple scripts to run simulations and analyze results without diving deep into the codebase.</li> </ul>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>Explore the comprehensive documentation to get the most out of the simulator:</p> <ul> <li>Architecture Overview: Dive into the system's design and understand how different components interact.</li> <li>Usage Guide: Step-by-step instructions on setting up and running simulations.</li> <li>Contributing: Want to contribute? Learn how you can help improve the simulator.</li> <li>API Reference: Detailed information about the simulator's classes and functions.</li> </ul>"},{"location":"#getting-started","title":"\ud83d\udee0 Getting Started","text":"<p>Ready to explore the Busy Beaver problem? Here's how to get started:</p> <ol> <li>Clone the Repository</li> </ol> <p><code>bash    git clone https://github.com/starolis/busy-beaver.git    cd busy-beaver</code></p> <ol> <li> <p>Set Up the Environment</p> <p><code>bash python3 -m venv venv source venv/bin/activate</code></p> </li> <li> <p>Install Dependencies</p> <p><code>bash pip install -r requirements.txt</code></p> </li> <li> <p>Run the Simulator</p> <p><code>bash python run_simulation.py</code></p> </li> </ol>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions to make this simulator even better! Check out our Contributing Guidelines for more details.</p>"},{"location":"#results","title":"\ud83d\udcc8 Results","text":"<p>After running simulations, you'll receive detailed reports highlighting:</p> <ul> <li>Most Productive Machines: Turing machines that print the highest number of 1s before halting.</li> <li>Longest-Running Machines: Machines that take the most steps to reach a halting state.</li> </ul> <p>Explore these results to gain insights into the computational power and efficiency of different Turing machine configurations.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#contact","title":"\ud83d\udceb Contact","text":"<p>Have questions or feedback? Reach out to matt@starol.is</p>"},{"location":"#acknowledgments","title":"\ud83c\udf93 Acknowledgments","text":"<ul> <li>Inspired by the fascinating concepts in Computation Theory and those who have pushed the field forward. \ud83d\ude4f</li> </ul>"},{"location":"architecture/","title":"Architecture Overview","text":""},{"location":"architecture/#modules","title":"Modules","text":""},{"location":"architecture/#1-turing_machinepy","title":"1. <code>turing_machine.py</code>","text":"<p>Defines the <code>TuringMachine</code> class, encapsulating the behavior of a Turing machine. It manages the tape, head position, current state, and execution steps.</p>"},{"location":"architecture/#2-simulationpy","title":"2. <code>simulation.py</code>","text":"<p>Handles the enumeration and simulation of all possible Turing machines based on defined states and symbols. Utilizes multiprocessing to parallelize simulations for efficiency.</p>"},{"location":"architecture/#3-utilspy","title":"3. <code>utils.py</code>","text":"<p>Contains utility functions and shared constants to support other modules.</p>"},{"location":"architecture/#workflow","title":"Workflow","text":"<ol> <li> <p>Enumeration: Generates all possible transition functions based on the number of states and symbols.</p> </li> <li> <p>Simulation: Each transition function is simulated using the <code>TuringMachine</code> class to determine if it halts and its productivity.</p> </li> <li> <p>Aggregation: Collects results to identify the most productive and longest-running halting machines.</p> </li> </ol>"},{"location":"architecture/#future-enhancements","title":"Future Enhancements","text":"<ul> <li> <p>Configurable Parameters: Allow dynamic configuration of states, symbols, and other parameters via configuration files or command-line arguments.</p> </li> <li> <p>Optimization: Implement more efficient algorithms or heuristics to reduce the simulation space.</p> </li> <li> <p>Visualization: Add visualization tools to represent machine behavior and tape states.</p> </li> <li> <p>Extended Testing: Increase test coverage for more robust validation.</p> </li> </ul>"}]}